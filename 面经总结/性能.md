#### 网页中有大量图片加载很慢，有什么办法进行优化？

------

- 预加载

- 懒加载

  优先加载可视区域的内容，等图片进入了可视区域，或者在图片的未可视区域加一个滚动条事件，判断图片位置与浏览器顶端的距离和页面的高度，如果前者小于后者，优先加载

  实现：给图片的 img 标签中的 src 属性初始值置空，把真正的图片链接放入 自定义属性中（data-*），当图片进入可视区域后，再把图片链接赋值给 src 属性

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
      .other-content {
        height: 500px;
        background: yellow;
      }
      .img-container {
        width: 300px;
      }
      .img {
        width: 300px;
        height: 300px;
      }
    </style>
  </head>
  <body>
    <div class="other-content"></div>
    <div class="img-container">
      <img class="img" src="" data-src="https://alifei01.cfp.cn/creative/vcg/veer/800water/veer-134642240.jpg">
      <img class="img" src="" data-src="https://alifei04.cfp.cn/creative/vcg/veer/800water/veer-142043813.jpg">
      <img class="img" src="" data-src="https://tenfei04.cfp.cn/creative/vcg/veer/800water/veer-150448228.jpg">
      <img class="img" src="" data-src="https://alifei04.cfp.cn/creative/vcg/veer/800water/veer-140960753.jpg">
      <img class="img" src="" data-src="https://alifei05.cfp.cn/creative/vcg/veer/800water/veer-150630194.jpg">
      <img class="img" src="" data-src="https://alifei03.cfp.cn/creative/vcg/veer/800water/veer-164428632.jpg">
      <img class="img" src="" data-src="https://alifei04.cfp.cn/creative/vcg/veer/800water/veer-170923883.jpg">
      <img class="img" src="" data-src="https://alifei01.cfp.cn/creative/vcg/veer/800water/veer-305149820.jpg">
      <img class="img" src="" data-src="https://alifei03.cfp.cn/creative/vcg/veer/800water/veer-121508242.jpg">
      <img class="img" src="" data-src="https://alifei02.cfp.cn/creative/vcg/veer/800water/veer-154371821.jpg">
      <img class="img" src="" data-src="https://tenfei04.cfp.cn/creative/vcg/veer/800water/veer-132362258.jpg">
      <img class="img" src="" data-src="https://alifei05.cfp.cn/creative/vcg/veer/800water/veer-312350154.jpg">
    </div>
    <script type="text/javascript">
      // 初始加载
      window.onload = function() {
        var imgs = document.querySelectorAll('img');
        // 因为不单单滚动时，要计算图片是否可视；初始时，有些图片可能就在可视范围内，所以初始时也要调用这个方法
        // 所以单独封装懒加载方法
        function lazyLoad(imgs) {
          // 可视区域的高度
          const innerWidth = window.innerWidth // 当前可视区域的宽度
          const innerHeight = window.innerHeight
          // 滚动的高度
          const scrollTop = document.documentElement.scrollTop || document.body.scrollTop
          // 滚动的宽度
          const scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft
          for(let i = 0; i < imgs.length; i++) {
            // offsetTop为图片相对于顶部的距离
            // 当可视区域高度 + 滚动高度 > 图片到顶部的距离时，说明图片已经在可视区域中
            if(innerHeight + scrollTop > imgs[i].offsetTop && innerWidth + scrollLeft > imgs[i].offsetLeft) {
              let temp = new Image()  // 临时创建一个图片对象，这是在内存中创建的，不会显示在页面上
              temp.src = imgs[i].getAttribute('data-src'); // 在图片对象上获取图片真实请求路径，进行加载，这个只会请求一次
              console.log(111, imgs[i].offsetTop) 
              // 当图片加载完成后，将地址替换到真实页面可视区域上图片的src
              temp.onload = function() {
                // 将真实图片替换
                imgs[i].src = temp.src
              }
            }
          }
        }
        // 初始时调用懒加载，保证在可视区域范围的图片正常加载
        lazyLoad(imgs)
        // 滚动时调用懒加载
        window.addEventListener("scroll", function() {
          lazyLoad(imgs)
        })
      }
    </script>
  </body>
  </html>
  ```

  **容器版本**

  ```html
  
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
      .other-content {
        height: 500px;
        background: yellow;
      }
      .img-container {
        width: 300px;
        height: 600px;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .img {
        width: 300px;
        height: 300px;
      }
    </style>
  </head>
  <body>
    <div class="other-content"></div>
    <div class="img-container">
      <img class="img" src="" data-src="https://alifei01.cfp.cn/creative/vcg/veer/800water/veer-134642240.jpg">
      <img class="img" src="" data-src="https://alifei04.cfp.cn/creative/vcg/veer/800water/veer-142043813.jpg">
      <img class="img" src="" data-src="https://tenfei04.cfp.cn/creative/vcg/veer/800water/veer-150448228.jpg">
      <img class="img" src="" data-src="https://alifei04.cfp.cn/creative/vcg/veer/800water/veer-140960753.jpg">
      <img class="img" src="" data-src="https://alifei05.cfp.cn/creative/vcg/veer/800water/veer-150630194.jpg">
      <img class="img" src="" data-src="https://alifei03.cfp.cn/creative/vcg/veer/800water/veer-164428632.jpg">
      <img class="img" src="" data-src="https://alifei04.cfp.cn/creative/vcg/veer/800water/veer-170923883.jpg">
      <img class="img" src="" data-src="https://alifei01.cfp.cn/creative/vcg/veer/800water/veer-305149820.jpg">
      <img class="img" src="" data-src="https://alifei03.cfp.cn/creative/vcg/veer/800water/veer-121508242.jpg">
      <img class="img" src="" data-src="https://alifei02.cfp.cn/creative/vcg/veer/800water/veer-154371821.jpg">
      <img class="img" src="" data-src="https://tenfei04.cfp.cn/creative/vcg/veer/800water/veer-132362258.jpg">
      <img class="img" src="" data-src="https://alifei05.cfp.cn/creative/vcg/veer/800water/veer-312350154.jpg">
    </div>
    <script type="text/javascript">
      const imgContainer = document.querySelector('.img-container')
      const imgs = document.querySelectorAll('.img')
      window.onload = function() {
        function lazyLoad(imgs) {
          // 容器可视区域的高度、宽度
          const {height, width} = window.getComputedStyle(imgContainer)
          const [innerHeight, innerWidth] = [parseInt(height), parseInt(width)]
          // 滚动的高度、宽度
          const {scrollTop, scrollLeft} = imgContainer 
          for(let i = 0; i < imgs.length; i++) {
            const [offsetTop, offsetLeft] = [imgs[i].offsetTop - imgContainer.offsetTop, imgs[i].offsetLeft - imgContainer.offsetLeft]
            // offsetTop为图片相对于顶部的距离
            // 当可视区域高度 + 滚动高度 > 图片到容器顶部的距离时，说明图片已经在可视区域中
            if(innerHeight + scrollTop > offsetTop && innerWidth + scrollLeft > offsetLeft) {
              let temp = new Image()  // 临时创建一个图片对象，这是在内存中创建的，不会显示在页面上
              temp.src = imgs[i].getAttribute('data-src'); // 在图片对象上获取图片真实请求路径，进行加载，这个只会请求一次
              // 当图片加载完成后，将地址替换到真实页面可视区域上图片的src
              temp.onload = function() {
                // 将真实图片替换
                imgs[i].src = temp.src
              }
            }
          }
        }
        // 初始时调用懒加载，保证在可视区域范围的图片正常加载
        lazyLoad(imgs)
        // 滚动时调用懒加载
        imgContainer.addEventListener("scroll", function() {
          lazyLoad(imgs)
        })
      }
    </script>
    <script src="./index.js"></script>
  </body>
  </html>
  ```

- 预加载

  - css 实现

    css 实现图片的预加载就是通过 `background-image`

    ```css
    .preloadImages {
           width: 0px;
           height: 0px;
           display: inline;
           background-image: url(path/to/image1.png);
           background-image: url(path/to/image2.png);
           background-image: url(path/to/image3.png);
           background-image: url(path/to/image4.png);
    }
    ```

    `width/height 设置为 0；display 设置为 inline` 是为了让这个预加载元素不会影响其他元素，使得前端无感知

  - JS 实现

    ```javascript
    let preload = new Image() // 并不会添加到文档流中
    preload.src = "https://alifei01.cfp.cn/creative/vcg/veer/800water/veer-134642240.jpg"
    preload.onload = function(){
        targetImageEle.src = preload.src
    }
    ```

- 雪碧图

  使用 cssSprite 或者 svgSprite，把多张小图片合并成一张大图片，一次性请求过来，然后用 css 切割需要的部分

- 改变图片大小

  裁剪图片，保留关键信息

  图片压缩