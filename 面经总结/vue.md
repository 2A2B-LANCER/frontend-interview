#### v-if 和 v-show 的区别

****

- `v-if`：原理是增删 vnode，会触发 虚拟 DOM 的更新，开销较大
- `v-show`：原理是控制 DOM 元素的 `display` 属性，开销相比 v-`if` 小

> 为什么 v-show 不用 visibility 属性？开销不更小吗？

因为 `visibility` 只是把元素隐藏起来，它还占据文档流中的位置



#### 双向绑定的原理

****

关键点就是数据劫持和发布-订阅模式

1. 数据劫持，通过 `Observer` 对象，递归遍历需要被监听的对象，都加上 `getter` 和 `setter`
2. `Dep` 对象就是发布者
3. `Watcher` 对象就是订阅者

> 数据变化 -> 视图更新（v-bind）
>
> 数据变化肯定会触发 `setter`，然后就会触发该 `Dep` 对象向 `Watcher` 们发布通知，更新该数据，`Watcher` 更新就会触发 VDOM 更新，然后触发视图更新

> 视图交互变化 -> 数据变化（v-on）
>
> 该过程是通过事件监听实现的，事件监听组件的数据变化，然后反馈到被劫持的数据上，触发 setter



#### Vue 的响应式系统

****

1. 所有的组件都有一个 Watcher 对象（订阅者）
2. 响应式对象的属性都会递归设置 `geter` 和 `setter` 进行数据劫持
3. 组件的 `render` 函数执行的时候，就会初始化 `Watcher` 对象，绑定的响应式对象都会递归调用 `getter` 方法，进行依赖收集，完成 发布者和订阅者之间的联系
4. 数据变化的时候，就会递归调用响应式对象的 `setter` 方法，`Dep` 对象就会通知所有订阅者进行更新



#### 既然 Vue 通过数据劫持可以精准探测数据变化,为什么还需要虚拟 DOM 进行 diff 检测差异

****

现代前端框架有两种方式侦测变化，一种是 `pull`，一种是 `push`

- `pull`：就是 **不知道哪里发生了变化，只知道变化了**，然后整个 VDOM 进行比较，查找变化的地方
- `push`：数据发生变化就会立即知道是哪里，Vue 因为所有的响应式对象都对使用它的组件的 `Watcher` 进行了依赖收集，这种发布-订阅模式使得数据变化可以侦听到具体组件，然后在通过 VDOM 的 Diff 算法检测具体差异，这部分就属于 `pull` 操作了



#### `Vue` 中 `key` 值的作用

****

为了在 VDOM 更新的时候能够复用相同 key 值的元素，提高 VDOM 更新的效率



#### 组件间通信的方式？

****

1. `props`/`$emit`
   1. 子组件设置 `props` 属性，父组件在子组件实例上使用同名属性传值
   2. 父组件在子组件实例上注册事件监听，在子组件内部用 `$emit` 调用该事件，传递值过去

