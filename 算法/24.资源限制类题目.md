#### 资源限制技巧汇总

1. 布隆过滤器用于集合的建立与查询，并可以节省大量空间
2. 一致性哈希解决数据服务器的负载管理问题
3. 利用并查集做岛数量问题的并行计算
4. 哈希函数把数据按照种类均匀分流
5. 位图解决某一范围上数字的出现情况，节省大量空间
6. 利用分段统计思想，进一步节省大量空间
7. 利用堆、外排序来做多个处理单元的结果合并

#### 题目一

题目：32 位无符号整数的范围是 0~4294967295，

现在正好有一个包函 40 亿个无符号整数的文件，可以使用最多 1GB 的内存，怎么找到出现次数最多的数



思路：（哈希函数分流）

1. 如果排序，需要的内存就是 40亿个数的数组的内存大小，（JAVA）一个无符号数 4 个字节，40亿个无符号数，160亿个字节，远超 1GB，不行
2. 如果用 HashMap 记录数字出现的次数，那么一条记录中键值都是无符号整数，也就是一条记录 8 字节，最差情况，40亿个无符号整数各不相同，也就需要40亿条记录，320亿个字节的内存，更不行

上面两种情况都超出内存限制了，既然这样，整体求解是行不通的了，那就只能分批次求解，但是我们知道，**众数**，在局部和整体中求解的值可是不一定一样的（如果数据是无序的话），所以我们就需要一个手段来给所有的数据进行分类，同一个数进入同一批次，这样有序求解，每个批次选出一个众数，再从局部众数选出全体众数，就可以了

所以，哈希函数分流就可以使用了：

以下是最差情况，也就是有 40 亿种数（比如从 1~40亿）

1. 估计 1GB 内存可以承担的数据量
2. 如果用 HashMap，一条数据8字节，1GB最多容纳 2^27条数据，大概1亿3000万条左右，保守估计的话，每组1千万条数据，分400组，也就是分 400 个文件
3. 用哈希函数求出每个数的哈希值，再 % 400，哈希函数特性，输入相同，输出必然相同，所以同一个数必然进入同一组；而且哈希函数具有离散型，所以 400 个文件的数据量大差不差，水平接近，这样就实现了有序分流
4. 然后每组分别求解众数，最后从 400 个众数中求出全局众数，问题解决

 

#### 题目二

题目：32 位无符号整数的范围是 0~4294967295，

现在有一个正好包含40亿个无符号整数的文件，

所以在整个范围中必然存在没出现过的数

可以使用最多1GB的内存，怎么找到所有未出现过的数？

【进阶】：内存限制为 3 KB，但是只用找到 1 个没出现过的数



分析：（位图）

这一题和第一题又不一样了，第一题要**众数**，众数有两个信息：

1. 数字
2. 个数

两个信息缺一不可；

但是这一题要 **未出现过的数**，那就只有一个信息，即数字；

32位无符号整数范围 0~2^32 - 1，如果我们用1位来标记一个数是否出现过，那就需要 2^32位的内存，即 0.5GB，就能标记所有数字出现与否的信息，小于 1GB，解题完毕



进阶分析：（分段统计思想）

进阶版又不一样了，这次不要所有未出现的，**只要一个未出现的**

内存限制是 3KB，一个无符号整数4字节，可以容纳的最多数字数就是 3KB / 4 B = 3 * 2^8个，再减去其他的内存开销，保守估计 2^9 个

申请一个 512 长度的数组，再把 0~2^32-1的长度分为 512份；遍历所有数字的时候，其对应的数组索引内存储的个数 + 1，这样遍历一遍之后，哪个小于 2^32 / 512，哪个区间就有数字未出现

然后在目标区间内重复这个过程，直到找出未出现的数字

再次进阶：

如果只让使用有限几个变量呢？

二分法。

目标长度上分为左右两部分，哪部分的数字个数小，哪部分就肯定有数字未出现，然后一直重复该过程，直到找出未出现数字

需要的变量有：

1. 左边界
2. 右边界
3. 中点
4. 左边的数字个数
5. 右边的数字个数



#### 题目三

有一个包函 100 亿个 URL 的大文件，假设每个 URL 占用 64 B，

请找出其中所有重复的 URL



思路：如果允许有失误率，则使用布隆过滤器；

否则使用哈希函数分流，这个分流分的就不是种类，而是数据本身，相同的肯定被分到一起，这样所有重复的就找到了



#### 题目四

32 位无符号整数的范围是 0~4294967295，现在有40亿个无符号整数，可以使用最多 1GB 的内存，找出所有出现了两次的数

思路：

使用**位图**（每两位标记一个数）来标记一个数出现的次数，00,01,10,11，最后统计 10 的数字

一共有2^32种数，也就是需要2^33位来标记，正好 1GB，如果担心爆内存，可以**分段统计**



#### 题目五

32 位无符号整数的范围是 0~4294967295，现在有40亿个无符号整数，可以使用最多 10MB 的内存，怎么找到这些数字的中位数



思路：（分段统计思想）

把0~2^32-1这个范围，分为不超过限定内存的数组长度份，然后统计没份有多少个数字，从前到后，数量累加，第20亿个（即中位数），肯定在某个范围内，找到该范围，记录之前的范围已经出现过多少个数字，在该范围内再找 20亿 - 已出现个数就是中位数；当然，重复分段这个操作



#### 题目六

32 位无符号整数的范围是 0~4294967295，

有一个 10G 大小的文件，每一行都装着这种类型的数字，

整个文件无序，限定 5G 的内存，

请输出 10G 大小的文件，就是原文件所有数字排序的结果



分析：这题很烦，输出原文件排序的结果，也就是三个信息：

1. 数字
2. 数字个数
3. 数字相对位置

考虑哈希函数分流，没有相对位置信息；

位图，数字个数不确定，不知道每个数字分配几位

这种情况下就需要堆了：

1. 申请一个不超过限定内存的大小，来充当堆这个容器（其中的记录都是数字及其出现次数组成的键值对）
2. 堆不满则直接放入，满了的话就判断当前数字与堆中最大数字的大小；小的话，挤掉最大的那个；大的话跳过
3. 这样遍历一遍之后，就得到了最小的 K 个数字及其出现次数，填充进输出文件，记录最大数字
4. 重复遍历填充过程，不过小于等于已记录的最大数字的直接跳过



#### 题目七

某搜索软件公司的每日搜索量巨大（百亿级别），

请设计一种合理的方式计算出每日的 TOP100

思路：根据内存限制，利用哈希分流分组，然后求出每组的TOP100，然后用堆的思想：

1. 找出每一组的TOP1，这些中次数最大的就是总体TOP1
2. 然后总体TOP1弹出他自己那一组，那一组原来的TOP2变成TOP1，重复1过程，找出TOP100