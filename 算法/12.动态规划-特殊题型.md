#### 最长回文子序列

> https://leetcode-cn.com/problems/longest-palindromic-subsequence/

子序列：可以不连续，比如 “abcdef” 的一个子序列可以是 ”abcef“

子串：必须是连续的，比如 “abcdef” 的一个子串可以是 ”abc“

```javascript
// 解法一：参照两个串的最长公共子序列，即原字符串和其逆序的最长公共子序列
var longestPalindromeSubseq = function(s) {
  let text1 = s,
      text2 = s.split('').reverse().join('')
      len1 = text1.length,
      len2 = text2.length,
      map = new Array(len1).fill(0).map(() => new Array(len2).fill(-1))
  map[0][0] = text1[0] === text2[0] ? 1 : 0
  for(let i=1; i<len1; i++){
    if(text1[i] === text2[0]){
      map[i][0] = 1
    }else{
      map[i][0] = map[i - 1][0]
    }
  }
  for(let i=1; i<len2; i++){
    if(text1[0] === text2[i]){
      map[0][i] = 1
    }else{
      map[0][i] = map[0][i - 1]
    }
  }
  for(let i=1; i<len1; i++){
    for(let j=1; j<len2; j++){
      const num1 = map[i][j - 1],
            num2 = map[i - 1][j]
      if(text1[i] === text2[j]){
        const num3 = 1 + map[i - 1][j - 1]
        map[i][j] = Math.max(num1,num2, num3)
      }else{
        map[i][j] = Math.max(num1, num2)
      }
    }
  }
  return map[len1 - 1][len2 - 1]
};
```



解法二：动态规划

分析回文串左右压缩生成的过程

1. 如果 left === right，肯定相等，`map[left][rgiht]` = 1

2. 如果 left + 1 === right，两种情况
   1.  左右端点字符相等，`map[left][rgiht]` = 2
   2. 左右端点字符不相等，`map[left][rgiht]` = 1

3. 如果 left !== right，三种情况
   1. 左端点不在回文串内，`map[left][rgiht]` = `map[left + 1][rgiht]`
   2. 右端点不在回文串内，`map[left][rgiht]` = `map[left][rgiht - 1]`
   3. 左右端点字符相等，都在回文串内，`map[left][rgiht]` = 2 + `map[left + 1][rgiht - 1]`

```javascript

var longestPalindromeSubseq = function(s) {
  let len = s.length,
      map = new Array(len).fill(0).map(() => new Array(len).fill(0))
  map[len - 1][len - 1] = 1
  for(let i=0; i<len; i++){
    map[i][i] = 1
    map[i][i + 1] = s[i] === s[i + 1] ? 2 : 1
  }
  for(let m=2; m<len; m++){
    for(let i=0,j=m; i<len && j<len; i++,j++){
      const num1 = map[i + 1][j],
            num2 = map[i][j - 1]
      if(s[i] === s[j]){
        const num3 = 2 + map[i + 1][j - 1]
        map[i][j] = Math.max(num1, num2, num3)
      }else{
        map[i][j] = Math.max(num1, num2)
      }
    }
  }
  console.log(map)
  return map[0][len - 1]
};
```



#### 跳马问题

题目：一张 10 x 9 的棋盘，以直角坐标系中的（0,0）为左下角

有象棋马从（0,0）出发，经过 K 步到达 （X,Y），问总共有多少种跳法

参数：X，Y，K

输出：跳法数目

```javascript
// 暴力递归
function getWays(x, y, rest, targetX, targetY) {
  if(x < 0 || x > 9 || y < 0 || y > 8){
    return 0
  }
  if(rest === 0){
    if(x === targetX && y === targetY){
      return 1
    }else{
      return 0
    }
  }else{
    res = getWays(x + 1, y + 2, rest - 1, targetX, targetY, map) +
    getWays(x + 2, y + 1, rest - 1, targetX, targetY, map) +
    getWays(x + 2, y - 1, rest - 1, targetX, targetY, map) +
    getWays(x + 1, y - 2, rest - 1, targetX, targetY, map) +
    getWays(x - 1, y - 2, rest - 1, targetX, targetY, map) +
    getWays(x - 2, y - 1, rest - 1, targetX, targetY, map) +
    getWays(x - 2, y + 1, rest - 1, targetX, targetY, map) +
    getWays(x - 1, y + 2, rest - 1, targetX, targetY, map)
  	return res
  }
}
```



```javascript
// 动态规划表
function getWays(x, y, rest, targetX, targetY, map) {
  if(map[x][y][rest]){
    return map[x][y][rest]
  }
  if(x < 0 || x > 9 || y < 0 || y > 8){
    return 0
  }
  let res = 0
  if(rest === 0){
    if(x === targetX && y === targetY){
      res = 1
    }
  }else{
    res = getWays(x + 1, y + 2, rest - 1, targetX, targetY, map) +
    getWays(x + 2, y + 1, rest - 1, targetX, targetY, map) +
    getWays(x + 2, y - 1, rest - 1, targetX, targetY, map) +
    getWays(x + 1, y - 2, rest - 1, targetX, targetY, map) +
    getWays(x - 1, y - 2, rest - 1, targetX, targetY, map) +
    getWays(x - 2, y - 1, rest - 1, targetX, targetY, map) +
    getWays(x - 2, y + 1, rest - 1, targetX, targetY, map) +
    getWays(x - 1, y + 2, rest - 1, targetX, targetY, map)
  }
  map[x][y][rest] = res
  return res
}
```



```javascript
// 动态规划
function getMapVal(x, y, rest, map){
  if(x < 0 || x > 9 || y < 0 || y > 8){
    return 0
  }else{
    return map[x][y][rest]
  }
}
function getMax(a,b,k){
  let map = new Array(10).fill(0).map(() => new Array(9).fill(0).map(() => new Array(k).fill(0)))
  map[a][b][0] = 1
  for(let rest = 1; rest<=k; rest++){
    for(let x = 0; x<10; x++){
      for(let y = 0; y<9; y++){
        map[x][y][rest] = 0
        map[x][y][rest] += getMapVal(x + 1, y + 2, rest - 1, map)
        map[x][y][rest] += getMapVal(x + 2, y + 1, rest - 1, map)
        map[x][y][rest] += getMapVal(x + 2, y - 1, rest - 1, map)
        map[x][y][rest] += getMapVal(x + 1, y - 2, rest - 1, map)
        map[x][y][rest] += getMapVal(x - 1, y - 2, rest - 1, map)
        map[x][y][rest] += getMapVal(x - 2, y - 1, rest - 1, map)
        map[x][y][rest] += getMapVal(x - 2, y + 1, rest - 1, map)
        map[x][y][rest] += getMapVal(x - 1, y + 2, rest - 1, map)
      }
    }
  }
  return map[0][0][k]
}

```



#### 第三题

暴动三：01:32:41

