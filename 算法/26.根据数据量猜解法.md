### 对数器找规律

也就是先写一个正确的暴力解，然后观察大量结果，得出规律

#### 题目一

小胡去买苹果，商店只提供两种类型的塑料袋，每种类型数量任意

1. 能装6个苹果
2. 能装8个苹果

小胡可以自由使用两种袋子装苹果，但是小胡有强迫症，他要求自己使用的袋子数量必须最少，且每个袋子必须装满。

参数：N：苹果个数

返回值：小胡在满足强迫症的情况下使用的袋子个数，如果不行返回 -1

分析：

既然最少，肯定是 8 的袋子用的最多的时候，剩下的苹果数不是0就是6的倍数，否则返回 -1



```javascript
function getMinBegs(N){
  for(let i = N >> 3; i>=0; i--){
    if((N - i * 8) % 6 === 0){
      return i + (N - i * 8) / 6
    }
  }
  return -1
}
```



分析N从1~200的结果发现

当 N<18 的时候没有规律

当 N>18 的时候，偶数为 3 + ((N - 18) >> 3)，奇数为 -1

所以

```javascript
function getMinBegs(N){
  if( N < 18){
    if([6, 8].includes(N)){
      return 1
    }else if([12, 14, 16].includes(N)){
      return 2
    }else{
      return -1
    }
  }else{
    return N % 2 === 0 ? 3 + ((N - 18) >> 3): -1
  }
}
```

这个时间复杂度明显更好，O(1)



#### 题目二

给定一个正整数 N，表示有 N 份青草统一堆放在仓库，有一只牛和一只羊，牛先吃，羊后吃，不管是牛还是羊，每一轮吃的草量必须是：1,4,16,64...(4 的某次方)

谁先吃完草，谁赢

假设牛羊都会为了赢做出理性的决定，根据参数 N，返回谁会赢



```javascript
function whoWin(n){
  if([0, 2].includes(n)){
    return "后手赢"
  }else if([1, 3, 4].includes(n)){
    return "先手赢"
  }else{
    for(let i = 0; Math.pow(4, i) <= n; i++){
      if(whoWin(n - Math.pow(4, i)) === "后手赢"){
        return "先手赢"
      }
      if(i <= n >> 2){
          continue
      }else{
          break
      }
    }
    return "后手赢"
  }
}
```

分析规律：后先后先先

```javascript
function whoWin(n){
  if([0, 2].includes(n % 5)){
    return "后手赢"
  }else{
    return "先手赢"
  }
}
```



#### 题目三

定义一种数：可以表示成若干（数量 > 1）连续正数和的数

比如：

5 = 2 + 3

12 = 3 + 4 + 5

1 不行，因为要求数量大于 1、连续正数和

2 = 1 + 1，2也不行，因为不连续

给定一个参数 N，返回 N 行不行



```javascript
// 暴力解法
function isMSum(n){
  for(let i=1; i<n; i++){
    let sum = i, j = i + 1
    while(sum < n){
      sum +=j
      j++
    }
    if(sum === n){
      return true
    }
  }
  return false
}
```



```javascript
// 找规律：2 的 某次方是 false
function isMSum(n){
    return (n & (-n) !== n
}
```



#### 总结

1. 某个题，输入参数类型简单，并且只有一个实际参数
2. 要求的返回值类型也简单，并且只有一个
3. 永波阿里方法，把输入参数对应的返回值，打印出来找规律



### 根据数据量规模猜解法

 

#### 题目四

数组 d：d[i] 表示 i 号怪兽的能力

数组 p：p[i] 表示 i 号怪兽要求的钱

开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。

如果你当前的能力，小于 i 号怪兽的能力，你必须付出 p[i] 的钱，贿赂这个怪兽，然后怪兽加入你，能力累加到你的能力上；如果你当前的能力，大于等于 i 号怪兽的能力，你可以选择直接通过，能力不会下降，也可以选择贿赂这个怪兽，然后怪兽就会加入你

返回通过所有的怪兽，需要花的最小钱数

要求运算时间 2~4s（C/C++ 要求 1s 内）

分析：这个时间限制，大概要求 10^8 次常数时间运算，超过这个次数，基本就超时了，所以我们要根据给出的数据格式，采用不同的解法

很明显，这是个 DP背包问题

根据之前 暴力递归改动态规划，我们很容易想到以 序号和能力值为参数的动态规划表，如果要顺利填满这张表，所需要的时间复杂度就是 O(N * M)，N 是怪兽个数，M 是全部贿赂所需钱数，如果，N * M 超过了 10^8 这个数量级，超时；

递归过程中的自变量有：

1. 序号
2. 能力值
3. 钱数

但是，能力值和钱数都是基于序号变动的，所以抛弃第一个尝试的话，接下来应该尝试一下 序号和钱数，能否做 DP表的维度

如果我们从最后一个怪兽往回看的话，当前怪兽有几种选择：

1. 假设不贿赂当前怪兽，那当前的钱和上只怪兽的钱是一样的
   1. 打到上只怪兽，我的能力值如果大于等于当前怪兽的能力值，可以；否则只能贿赂
2. 假设贿赂当前怪兽，那上只怪兽的钱应该是现在的钱减去当前怪兽的花销
   1. 只要能打到上只怪兽，就可以，因为这只怪兽选择贿赂，对能力值没有要求
3. 在上述两种情况中，选择最终能力值大的进行选择，返回能力值

这就是递归的流程，base case 就是当序号等于 -1 的时候，此时如果钱数是 0 的话，返回0，否则返回 -1

这个尝试，改动态规划的话，填充表的时间应该是 序号 * 全部都贿赂的钱数，看这个是否超过 10^8



#### 题目五

给定一个非负数组 arr，和一个正数 m

返回 arr 的所有子序列中累加和 %m 之后的最大值



```javascript
function max(arr, m){
    const len = arr.length,
          dp = new Array(len).fill(0).map(() => new Array(m).fill(false))
    for(let i=0; i<len; i++){
        dp[i][0] = true
    }
    dp[0][arr[0] % m] = true
    for(let i=1; i<len; i++){
        for(let j=0; j<m; j++){
            dp[i][j] = dp[i - 1][j]
            let current = arr[i] % m
            if(current <= j){
                dp[i][j] |= dp[i - 1][j - current]
            }else{
                dp[i][j] |= dp[i - 1][m + j - current]
            }
        }
    }
    for(let i=m-1; i>=0; i--){
        if(dp[n - 1][i]){
            return i
        }
    }
}
```



#### 题目六

> https://www.nowcoder.com/questionTerminal/d94bb2fa461d42bcb4c0f2b94f5d4281

一共有 n 袋零食，第 i 袋零食体积为 v[i]，背包容量为 w。

在总体即不超过背包容量的情况下，

一共有多少种零食放法，体积为 0 也算是一种

1 <= n <= 30

1 <= w <= 2 * 10^9

0 <= v[i] <= 10^9



思路：分治



### 卡特兰数

k(0) = 1, k(1) = 1时，如果接下来的项满足：

k(n) = k(0) * k(n - 1) + k(1) * k(n - 2) + ... + k(n - 2) * k(1) + k(n - 1) * k(0) 

或者

k(n) = c(2n, n) - c(2n, n - 1)

或者

k(n) = c(2n, n) / (n + 1)

就说这个表达式，满足卡特兰数



经典相关题目：

1. 有 n 个 `(`，n 个 `)`，问有多少种合法的括号排列方式（使用范式2）

2. 有 n 个节点，所有节点都无差别，问有多少种二叉树排列方式（使用范式1）



等势集：若存在从集合A到集合B的一一对应（双射），则称A与B等势（或对等），记作A~B。相应地，称A、B为等势集（亦称对等集、等基数集）。

