### 对数器找规律

也就是先写一个正确的暴力解，然后观察大量结果，得出规律

#### 题目一

小胡去买苹果，商店只提供两种类型的塑料袋，每种类型数量任意

1. 能装6个苹果
2. 能装8个苹果

小胡可以自由使用两种袋子装苹果，但是小胡有强迫症，他要求自己使用的袋子数量必须最少，且每个袋子必须装满。

参数：N：苹果个数

返回值：小胡在满足强迫症的情况下使用的袋子个数，如果不行返回 -1

分析：

既然最少，肯定是 8 的袋子用的最多的时候，剩下的苹果数不是0就是6的倍数，否则返回 -1



```javascript
function getMinBegs(N){
  for(let i = N >> 3; i>=0; i--){
    if((N - i * 8) % 6 === 0){
      return i + (N - i * 8) / 6
    }
  }
  return -1
}
```



分析N从1~200的结果发现

当 N<18 的时候没有规律

当 N>18 的时候，偶数为 3 + ((N - 18) >> 3)，奇数为 -1

所以

```javascript
function getMinBegs(N){
  if( N < 18){
    if([6, 8].includes(N)){
      return 1
    }else if([12, 14, 16].includes(N)){
      return 2
    }else{
      return -1
    }
  }else{
    return N % 2 === 0 ? 3 + ((N - 18) >> 3): -1
  }
}
```

这个时间复杂度明显更好，O(1)



#### 题目二

给定一个正整数 N，表示有 N 份青草统一堆放在仓库，有一只牛和一只羊，牛先吃，羊后吃，不管是牛还是羊，每一轮吃的草量必须是：1,4,16,64...(4 的某次方)

谁先吃完草，谁赢

假设牛羊都会为了赢做出理性的决定，根据参数 N，返回谁会赢



```javascript
function whoWin(n){
  if([0, 2].includes(n)){
    return "后手赢"
  }else if([1, 3, 4].includes(n)){
    return "先手赢"
  }else{
    for(let i = 0; Math.pow(4, i) <= n; i++){
      if(whoWin(n - Math.pow(4, i)) === "后手赢"){
        return "先手赢"
      }
      if(i <= n >> 2){
          continue
      }else{
          break
      }
    }
    return "后手赢"
  }
}
```

分析规律：后先后先先

```javascript
function whoWin(n){
  if([0, 2].includes(n % 5)){
    return "后手赢"
  }else{
    return "先手赢"
  }
}
```



#### 题目三

定义一种数：可以表示成若干（数量 > 1）连续正数和的数

比如：

5 = 2 + 3

12 = 3 + 4 + 5

1 不行，因为要求数量大于 1、连续正数和

2 = 1 + 1，2也不行，因为不连续

给定一个参数 N，返回 N 行不行



```javascript
// 暴力解法
function isMSum(n){
  for(let i=1; i<n; i++){
    let sum = i, j = i + 1
    while(sum < n){
      sum +=j
      j++
    }
    if(sum === n){
      return true
    }
  }
  return false
}
```



```javascript
// 找规律：2 的 某次方是 false
function isMSum(n){
    return (n & (-n) !== n
}
```



#### 总结

1. 某个题，输入参数类型简单，并且只有一个实际参数
2. 要求的返回值类型也简单，并且只有一个
3. 永波阿里方法，把输入参数对应的返回值，打印出来找规律



### 根据数据量规模猜解法

39

1:19:03