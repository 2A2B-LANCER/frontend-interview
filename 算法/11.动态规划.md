#### 第一题

题目：假设有排成一行的 N 个位置，记为 1~N，N 一定大于等于 2

开始时机器人在其中的 M 位置上（M 一定是 1~N 中的一个）

如果机器人来到 1 ，下一步只能去 2

如果机器人来到 N，下一步只能去 N - 1

如果机器人来到 [2, N - 1]，下一步可以左也可以右

规定机器人必须走 K 步，最终能来到 P 位置的方法有多少种

参数：N，M，K，P

返回值：方法数



```javascript
// 方案一：暴力递归
function walk(n, cur, rest, target){
  if(rest === 0){
    return cur === target ? 1 : 0
  }
  if(cur === 1){
    return walk(n, 2, rest - 1, target)
  }
  if(cur === n){
    return walk(n, n - 1, rest - 1, target)
  }
  return walk(n, cur - 1, rest - 1, target) + walk(n, cur + 1, rest - 1, target)
}
```

状态：

1. 剩余步骤 === 0：此时如果在目标点，说明这个路线可以，结果 + 1；否则结果 + 0
2. 剩余步骤大于0：
   1. 如果当前位置是边界（1 / N - 1），则只能往内部移动
   2. 如果当前位置是内部任意一点，可以往左右两边移动
   3. 汇总路线数



```javascript
// 方案二：自顶向下的动态规划（记忆化搜索）
function walk(n, cur, rest, target, map){
  if(map[cur - 1][rest - 1] > -1){
    return map[cur - 1][rest - 1]
  }else{
    if(rest === 0){
      return cur === target ? 1 : 0
    }else{
      let ways = 0
      if(cur === 1){
        ways = walk(n, 2, rest - 1, target, map)
      }else if(cur === n){
        ways = walk(n, n - 1, rest - 1, target, map)
      }else{
        ways = walk(n, cur - 1, rest - 1, target, map) + walk(n, cur + 1, rest - 1, target, map)
      }
      map[cur - 1][rest - 1] = ways
      return ways
    }
  }
}
```

画完方案一的树状图之后会发现，在一层当中，可能会出现重复访问，这样就能以 `cur_rest` 为键值，存储路线数，再次访问到这种情况的时候就能直接取出



分析递归函数执行过程中，dp图的生成会发现：

1. 当 剩余步数 === 0 的时候，除了目标点 === 1，其他都是 0
2. 当 当前位置 === 1 的时候，路线数 === map(2， rest - 1)
3. 当 当前位置 === N 的时候，路线数 === map(n - 1, rest - 1)
4. 当 当前位置 === 普通位置的时候，路线数 === map(cur - 1, rest - 1) + map(cur + 1, rest - 1)

分析可知，当我们获取到 剩余步数 === 0 的 dp图之后，就已经可以推导出剩余所有的数据了



```javascript
// 方案三 自底向上的动态规划
function walk(n, rest, target, map){
  map[target][0] = 1
  for(let j=1; j<rest + 1; j++){
    map[1][j] = map[2][j - 1]
    for(let i=2; i<n; i++){
      map[i][j] = map[i - 1][j - 1] + map[i + 1][j - 1]
    }
    map[n][j] = map[n - 1][j - 1]
  }
}
function getWays(n, start, rest, target) {
  const map = new Array(n + 1).fill(0).map(x => new Array(rest + 1).fill(0))
  walk(n, rest, target, map)
  return map[start][rest]
}
```



#### 第二题

题目：给定一个整形数组 arr，代表数值不同的纸牌排成一条线

玩家A 和玩家B 依次拿走每张纸牌

规定玩家A 先拿，玩家B 后拿

但是每个玩家每次只能拿走最左或最右的纸牌

返回最后获胜者的分数



分析：

1. 先手的人有两种选择
   1. 先手拿左边界，后手拿（left + 1, right）
   2. 先手拿右边界，后手拿（left, right - 1）
   3. 然后从这两种情况中拿最大的可能
2. 后手的人有两种选择
   1. 这一轮左边界被先手拿了，下一轮先手拿（left + 1, right）
   2. 这一轮右边界被先手拿了，下一轮先手拿（left, right - 1）
   3. 然后从这两种情况中拿最大的可能

```javascript
function first(arr, left, right){
  // 先手函数
  if(left === right){
    return arr[left]
  }else{
    const p1 = arr[left] + second(arr, left + 1, right),
        p2 = arr[right] + second(arr, left, right - 1)
    return Math.max(p1, p2)
  }
}
function second(arr, left, right){
  // 后手函数
  if(left === right){
    return 0
  }else{
    const p1 = first(arr, left + 1, right),
          p2 = first(arr, left, right - 1)
    return Math.min(p1, p2)
  }
}
function getMax(arr){
    // 入口函数
    const A = first(arr, 0, arr.length - 1),
          B = second(arr, 0, arr.length - 1)
    return Math.max(A, B)
}
```

