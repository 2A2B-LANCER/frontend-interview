#### 先序遍历 根左右

> https://leetcode-cn.com/problems/binary-tree-preorder-traversal/

```javascript
var preorderTraversal = function(root) {
  let stack = [],
      res = []
  stack.push(root)
  while(stack.length){
    let target = stack.pop()
    if(target.right){
      stack.push(target.right)
    }
    if(target.left){
      stack.push(target.left)
    }
    res.push(target.val)
  }
  return res
};
```

#### 中序遍历 左根右

> https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/



```javascript
var inorderTraversal = function(root) {
  let stack = [],
      res = [],
      node = root
  while(stack.length || node){
    if(node){
      stack.push(node)
      node = node.left
    }else{
      let target = stack.pop()
      res.push(target.val)
      node = target.right
    }
  }
  return res
};
```



#### 后序遍历 左右根

> https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/

```javascript
var postorderTraversal = function(root) {
  if(!root) return []
  let stack = [],
      res = []
  stack.push(root)
  while(stack.length){
    let target = stack.pop()
    if(target.left){
      stack.push(target.left)
    }
    if(target.right){
      stack.push(target.right)
    }
    res.push(target.val)
  }
  return res.reverse()
};
```



#### 递归序

递归一个二叉树的时候，每个节点都会访问到三次，这个访问顺序就是递归序，先、中、后序都可以由此加工而来

```javascript
function traversal(root){
    if(!root) return
    // 先序在这操作根节点
    preorderTraversal(root.left)
    // 中序在这操作根节点
    preorderTraversal(root.right)
    // 后序在这操作根节点
}
```



#### 层序遍历

> https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/

```javascript
var levelOrder = function(root) {
  if(!root) return []
  const queue = [],
        res = []
  queue.push(root)
  while(queue.length){
    const len = queue.length,
          ans = []
    for(let i=0; i<len; i++){
      const target = queue.shift()
      ans.push(target.val)
      if(target.left){
        queue.push(target.left)
      }
      if(target.right){
        queue.push(target.right)
      }
    }
    res.push(ans)
  }
  return res
};
```



#### 序列化、反序列化

> https://leetcode-cn.com/problems/h54YBf/submissions/

```javascript
// 层序遍历（循环，队列）
var serialize = function(root) {
  if(!root) return [].toString()
  const queue = [],
        res = []
  queue.push(root)

  function queuePush(val){
    if(val){
      queue.push(val)
    }else{
      queue.push('#')
    }
  }

  while(queue.length){
    const target = queue.shift()
    if(target !== '#'){
      res.push(target.val)
      queuePush(target.left)
      queuePush(target.right)
    }else{
      res.push('#')
    }
  }
  return res.toString()
};

function genNode(val){
  if(val !== '#'){
    return new TreeNode(val)
  }else{
    return null
  }
}

var deserialize = function(data) {
    if(data === ''){
      return null
    }
    let arr = data.split(','),
        root = new TreeNode(arr.shift()),
        queue = [root]
    while(queue.length){
      const target = queue.shift()
      target.left = genNode(arr.shift())
      target.right = genNode(arr.shift())
      if(target.left){
        queue.push(target.left)
      }
      if(target.right){
        queue.push(target.right)
      }
    }
    return root
};
```

```javascript
// 先序（递归）
var serialize = function(root) {
  const res = []
  function pre(root){
    if(!root){
      res.push('null')
      return
    }
    res.push(root.val)
    pre(root.left)
    pre(root.right)
  }
  pre(root)
  return res.toString()
};

function pre(arr){
  const val = arr.shift()
  if(val === 'null'){
    return null
  }
  const root = new TreeNode(val)
  root.left = pre(arr)
  root.right = pre(arr)
  return root
}

var deserialize = function(data) {
  const arr = data.split(',')
  return pre(arr)
};
```

