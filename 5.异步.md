### 回调函数

> In JavaScript, functions are first-class objects

因为**“函数在JavaScript中是一等公民”**，所以**函数可以作为参数被传递**给另一个函数，然后执行传入的参数，甚至返回它以供稍后执行。这就是回调函数的本质

> 回调函数：也被称为高阶函数，是指将函数作为参数传递给另一个函数（otherFunction），并在otherFunction内部执行回调函数

```javascript
// jQuery 常用用法
$("#btn_1").click(function() {
  alert("Btn 1 Clicked");
});

// 原生 JS 常用用法
var friends = ["Mike", "Stacy", "Andy", "Rick"];

friends.forEach(function (eachName, index){
console.log(index + 1 + ". " + eachName); // 1. Mike, 2. Stacy, 3. Andy, 4. Rick
});
```

#### 回调函数如何工作

当一个回调函数被当作参数传递给另一个函数（otherFunction）的时候，我们只是传递了回调函数的**定义**，并没有在这个过程中执行回调函数；正是因为回调函数会在 otherFunction 内的某个点执行，才会被叫做**回调函数**

#### 实现回调函数的基本原则

1. 使用具名、匿名、箭头函数作为回调函数
2. 可以给回调函数传递参数
3. 在执行回调函数之前确保它是个函数
4. 当回调函数中使用了 `this` 的时候，一定要确保 `this` 绑定到了你想绑定的对象上

```javascript
var clientData = {
    id: 094545,
    setUserName: function (firstName, lastName)  {
      this.fullName = firstName + " " + lastName;
    }
}
function getUserInput(firstName, lastName, callback)  {
    callback (firstName, lastName);
}
function getUser(firstName, lastName, callback, callbackObj)  {
    callback.apply (callbackObj, [firstName, lastName]);
}
getUserInput ("Barack", "Obama", clientData.setUserName);
console.log (clientData.fullName);// undefined
console.log (window.fullName); // Barack Obama

getUserInput ("Barack", "Obama", clientData.setUserName, clientData);
console.log (clientData.fullName);// Barack Obama
```

5. 允许多个回调函数

#### 可能出现的问题

1. 回调地狱
2. 控制反转：回调函数中的代码是我们希望程序在某个节点之后执行的代码，但是代码什么时候执行？执行几次，我们都无从得知，这样控制权就被交到了第三方手里，这就叫做控制反转

### Promise

在 `JavaScript` 中，如果我们想要在某个函数执行结束（某个点）的时候得到通知，去做一些事情，这个函数什么时候结束我不需要知道，那我们以往会怎么做呢？

上面这段描述不就是回调函数吗，但是回调函数有着缺乏顺序性和可信任性的问题，`Promise` 应运而生

使用 `Promise` 当到了 **未来的某一刻** 之后，那个 **未来某一时刻产生的值** 会被 `Promise` 收集到，接着去做想做的事（即以前在回调函数中做的事）

我理解的反控制反转就是：回调函数不再需要参与到包含函数的执行当中去，监听程序（第三方协商机制）获取到了想要的东西之后传递给回调函数（监听处理程序），那这种情况下，包含函数和回调函数的耦合度降低了，回调函数的执行权也回到了我们自己的手里，所以就实现了反控制反转。

> 识别 Promise（或者行为类似于 Promise 的东西）就是定义某种称为 thenable 的东西，将其定义为任何具有 then(..) 方法的对象和函数。我们认为，任何这样的值就是 Promise 一致的 thenable。

> 根据一个值的形态（具有哪些属性）对这个值的类型做出一些假定。这种类型检查（type check）一般用术语鸭子类型（duck typing）来表示

```javascript
if (
 p !== null &&
 (
 typeof p === "object" ||
 typeof p === "function"
 ) &&
 typeof p.then === "function"
) {
 // 假定这是一个thenable!
}
else {
 // 不是thenable
}
```

#### Promise信任问题

那为什么我们要反控制反转呢？控制反转带来了什么弊端呢？

控制反转的信任问题有：

- 调用回调过早
- 过晚（甚至不被调用）
- 次数过多或过少
- 吞掉可能出现的错误和异常

1. 调用过早或过晚

Promise的同步代码（即决议部分）运行之后，其**任务链（Promise().then(...).then(...)）**就会被添加到微任务队列，待这一批宏任务执行完毕之后执行。因为ES6新的事件循环机制，**不会出现决议部分的代码有时同步完成有时异步完成而导致的竞态条件**；也不会出现某个微任务被嵌套的微任务打断的情况（例子见 JS运行机制）

2. 次数不对

因为一个 `Promise` 只能被决议一次，所以不可能出现调用次数不对的情况

3. 吞掉错误和异常

在 `Promise` 的决议过程中，任何错误和异常都会导致其决议为 `rejected` 从而执行 `then` 中的第二个函数或者任务链上的 `catch()` 

#### 链式调用

链式调用的基础是：`Promise` 的 `then()` 和 `catch()` 会自动使用 `Promise.resolve()` 包装返回值

但是自动包装是立即完成的，也就是说这一条链相互之间属于“同步”，如果我们想要让彼此之间产生异步的话，就需要手动新建一个 `Promise` ，在其中填充你想要的异步操作

**为什么叫resolve()，而不是fulfilled()**

因为，如果给 `resolve()` 传递的参数是一个 `Promise` ，就会直接返回这个 `Promise` 的决议状态和值；如果传递参数是一个 `thenable` 的话，会展开它，返回相应的决议状态和值；如果是其他类型的话，则会打包成 `fulfilled` 状态返回

但是 `reject()`，只会将参数打包成 `rejected` 状态返回

#### Promise模式

1. `Promise.all([...])`

   参数（iterable类型包括 `Array，Map，Set`）中的值应该是 `Promise` ，也可以是 `tHenable` / `立即值` ，因为所有的值都会经过 `Promise.resolve()` 包装

   如果所有的 `Promise实例` 都成功，则返回一个 `resolve()` 回调，值为 `resolve()回调结果数组`

   但凡有一个失败，返回第一个失败的 `reject()回调`，值为其失败原因

2. `Promise.race([...])`

与 `Promise.all([ .. ])` 类似，一旦有任何一个 `Promise` 决议为完成，`Promise.race([ .. ])` 就会完成；一旦有任何一个 Promise 决议为拒绝，它就会拒绝。

**超时模式**

```javascript
// 前面定义的timeoutPromise(..)返回一个promise，
// 这个promise会在指定延时之后拒绝
// 为foo()设定超时
Promise.race( [
 foo(), // 启动foo()
 timeoutPromise( 3000 ) // 给它3秒钟
] )
.then(
 function(){
 // foo(..)按时完成！
 },
 function(err){
 // 要么foo()被拒绝，要么只是没能够按时完成，
 // 因此要查看err了解具体原因
 }
); 
```

3. `Promise.allSettled([...])`

   当所有的 `Promise` 都已经决议之后（无论成功失败），返回一个对象数组，每个对象包含对应的 `Promise`决议结果



### 生成器和迭代器



### async await



### JS运行机制

> https://juejin.cn/post/6844904050543034376#heading-21

#### 渲染进程Renderer的主要线程

**GUI渲染线程**

- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等
  - 解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree
  - 解析css，生成CSSOM(CSS规则树)
  - 把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)
- 当我们修改了一些元素的颜色或者背景色，页面就会**重绘(Repaint)**
- 当我们修改元素的尺寸，页面就会**回流(Reflow)**
- **当页面需要Repaing和Reflow时GUI线程执行，绘制页面**
- 回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免Reflow和Repaint
- **GUI渲染线程与JS引擎线程是互斥的**
  - 当JS引擎执行时GUI线程会被挂起(相当于被冻结了)
  - GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行



**JS引擎线程**

- JS引擎线程就是JS内核，负责处理Javascript脚本程序(例如V8引擎)

- JS引擎线程负责解析Javascript脚本，运行代码

- JS引擎一直**等待着任务队列中任务的到来，然后加以处理**
  - 浏览器同时只能有一个JS引擎线程在运行JS程序，所以js是单线程运行的
  - 一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序

- GUI渲染线程与JS引擎线程是互斥的，js引擎线程会阻塞GUI渲染线程
  - 就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)
  - 例如浏览器渲染的时候遇到`<script>`标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容。所以如果js执行时间太长就会造成页面卡顿的情况



**事件触发线程**

- **属于浏览器**而不是JS引擎，用来控制事件循环，并且管理着一个事件队列(task queue)

- 当JS执行碰到事件绑定和一些异步操作(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理。

- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理

- 因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理



**定时触发器线程**

- `setInterval`与`setTimeout`所在线程

- 浏览器定时计数器并不是由JavaScript引擎计数的(因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)

- 通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程

- W3C在HTML标准中规定，规定要求`setTimeout`中低于4ms的时间间隔算为4ms



**异步HTTP请求线程**

- 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求

- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行

- 简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行

```javascript
alert(1)
setTimeout(alert, 0, 8);
new Promise((resolve, reject) => {alert(2);resolve()}).then( function(){
 new Promise((resolve, reject) => {setTimeout((func)=> {alert(5);func()}, 0, resolve)}).then( function(){
    setTimeout(alert, 0, 11);
    alert(10);
 } );
 setTimeout(alert, 0, 9);
 alert(6)
} );
new Promise((resolve, reject) => {alert(3);resolve()}).then( function(){
 alert(7);
} );
alert(4);
```

