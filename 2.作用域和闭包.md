### 1. 作用域

#### 1.1 词法作用域和动态作用域

`JavaScript`采用词法作用域，作用域是函数定义时按照函数嵌套确定的；

动态作用域则是在函数调用的时候，基于函数调用栈确定的；

```javascript
function foo(){
    console.log(a);
}
function func(){
    var a = 'func';
    foo();	// global
}
var a = 'global';
func();
```

以词法作用域分析上述代码：

1. `foo`执行，在`foo`的函数作用域中寻找变量`a`的声明；
2. 没有找到，沿着函数定义时的作用域嵌套，查找外层作用域，在上述代码中就是全局作用域，找到`a`的声明，执行语句`console.log(a)`，打印`global`;

以动态作用域分析：

1. `foo`执行，在`foo`的函数作用域中寻找变量`a`的声明；
2. 没有找到，沿着函数调用栈，查找上层作用域，在上述代码中就是函数`func`的作用域，找到`a`的声明，执行语句`console.log(a)`，打印`func`;

实际情况打印`global`，由此也能看出`JavaScript`采用的是词法作用域。

#### 1.2 执行上下文

##### V8中JS的编译执行过程

1. 分词/词法分析

分词：例如 `var a = 2;`这条语句，会被分词为 `var` `a` `2` `;`这样的原子符号。

词法分析：检测当前作用域的变量和函数声明，并添加到**词法环境（Lexical Environment）**的内存空间当中

2. 语法分析

引擎将词法单元流转换成为**抽象语法树（Abstract Syntax Tree，AST）**，这一步如果有**语法错误（SyntaxError）**就会直接报错，不再继续执行代码。

3. 代码生成

生成执行用的字节码、机器码

##### 创建词法环境

在词法分析阶段，变量和函数声明会被添加到**词法环境（Lexical Environment）**中

词法环境有两部分：

1. 环境记录（Environment Record）：
   - 声明式环境记录（Declarative Environment Record）：用来记录var、let、const、class、module、import、函数声明
   - 对象式环境记录（Object Environment Record）：记录with、global
2. 对外部词法环境的引用（outer），形成作用域链的关键

```javascript
function func(){
    function funcF(){}
    var funcX = 10;
    let funcY = 10;
    const PI_2 = 3.1415926;
    var funcFoo = function(){}
    class Person(){}
}
var x = 10;
let y = 10;
const PI = 3.1415926;
var foo = function(){}
class Car(){}
```

比如上面这段代码词法环境的图解：

![image-20211208231021026](C:\Users\bengk\AppData\Roaming\Typora\typora-user-images\image-20211208231021026.png)

可以看到`var、函数声明`和`其他类型的声明结果有些不一样`，这就是**提升**

在 **词法分析** 阶段，会发生变量提升和函数提升，对象是`var`声明的变量和`函数声明`

- 对于`var`声明，会初始化为 `undefined`，赋值语句在真正执行代码时才会进行
- 对于函数声明会在内存中创建函数对象，并直接初始化为该函数对象

**暂时性死区**：观察`var、函数声明`以外的声明，全部都初始化为了 `uninitialized(未初始化的)`，在这些声明之前访问这些变量的话会抛出 `ReferenceError: xxx is not defined` 的错误，这就是**暂时性死区**

#### 1.3 函数作用域

> 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用（事实上在嵌套的作用域中也可以使用）。

> 最小特权原则：也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。

> 函数声明：形如 `function func(){ ... }`，没有包含在赋值语句中的，是函数声明，具有特性：**函数声明提升**，即函数声明会被提升至作用域顶部，声明之前即可使用

> 函数表达式：形如`let func = function funcName(){ ... }`或者 `let func = function(){ ... }`，包含在赋值语句中的，是函数表达式，没有 **提升**，即在赋值之前不能使用

#### 1.4 提升

1. `var声明`的变量和`函数声明`会提升至该函数作用域顶部；

```javascript
func();
console.log(x);	// undefined
function func(){
    console.log(a);	// undefined
    var a = 10;
}
var x = 10;
```

2. 提升这个操作是在编译时进行的；
3. 函数和var声明同一个名称时，函数声明生效；

```javascript
foo(); 	// this is a function
var foo;
foo();	// this is a function
function foo(){
    console.log('this is the first function');
}
foo = function(){
    console.log('this is the second function');
}
foo();	// this is the second function
```

2. `let`和`const`声明的变量不会提升；

```javascript
console.log(x);	// ReferenceError: x is not defined
let x = 10;
```



### 2. 闭包

